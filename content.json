{"pages":[{"title":"links","text":"友情链接","link":"/DALAOs.html"},{"title":"关于","text":"关于罗盘的一切一个还在奋斗中的大学狗，大家可以叫我罗盘或者Compass。 接下来的一年可能会因为考研等等事情忘了还有这个博客的人。 爱魔禁，爱技术，也爱交朋友！喜欢关于镰池和马这个作家的一切。 关于这个博客目前暂时搭在码云Github上后面会考虑迁移到服务器上（鸽子预定）（码云各种意义上太捞了，部署到了Github上） 会写什么大概什么都有（？） 主要会记录一些技术学习中遇到的问题，也会记录一些考研路上的点点滴滴（帮忙踩坑？）","link":"/about.html"}],"posts":[{"title":"Android中活动的生命周期","text":"Activity的生命周期是安卓开发中很重要的一个点，也是在面试中经常会被问到的一点，属于需要好好了解的一部分知识 首先在这里安利一下Google官方的开发者文档，虽然是繁体中文但是大致上不影响阅读，可能需要科学上网——https://developer.android.google.cn/guide/components/activities/ ，在这里Google详细讲述了安卓活动相关的种种细节，希望在通过各种书籍视频学习时也一定要阅读这部分内容！ 活动状态在《第一行代码》第2版中将活动分为四种状态： 运行状态 暂停状态 停止状态 销毁状态 而在官方文档中，将活动分为三种状态： 已继续 已暂停 已停止 其实本质上相同，只是官方文档认为活动销毁后便不再算入生命周期。 当活动处在屏幕最前端且具有使用者焦点时，认为活动处于运行状态；当活动失去焦点，但仍然可见，即上层覆盖一个并不占用全屏幕的活动时进入暂停状态；当活动完全不可见（被另外一个活动完全遮挡）但仍存在于内存中时处于停滞状态。对于暂停或停止的活动，可以调用finish()方法销毁，使其在内存中清除。 活动的生命周期回调Activity类定义了7个回调方法： public class ExampleActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 活动被创建时调用 } @Override protected void onStart() { super.onStart(); // 活动由不可见变成可见时调用 } @Override protected void onResume() { super.onResume(); // 当活动准备好与用户交互时调用（活动本身处于运行状态） } @Override protected void onPause() { super.onPause(); // 当另一个活动获得焦点时调用，在这个方法中将一些消耗CPU的资源释放，保存一些关键数据，但执行速度要快，不能影响到新的栈顶活动 } @Override protected void onStop() { super.onStop(); // 当活动完全不可见时调用 } @Override protected void onDestroy() { super.onDestroy(); // 程序销毁前执行 } } 活动的生存期可以分为三部分： 完整生存期：onCreate()和onDestory()方法之间 可见生存期：位于onStart()和onStop()方法之间，在这个生存期内活动对于用户总是可见的，但有可能无法与用户交互（焦点不聚焦在本活动） 前台生存期：onResume()方法和onPause()方法之间所经历的就是前台生存期，这个时期活动总是可以与用户交互 下面是谷歌官方提供的活动生命周期的示意图： 活动被回收了怎么办？如果想要在活动被回收后恢复活动需要使用onSaveInstanceState()方法，这个方法携带一个Bundle类型的参数，Bundle提供了一系列用于保存数据的方法，每个保存方法需要传入两个值——键（用于取回值）和需要保存的内容。 保存的数据如何恢复？ 大家可能以及注意到在onCreate()方法中有Bundle类型的参数，在一般情况下这个参数为NULL，但是如果活动被回收前有通过onSaveInstanceState()方法保存数据，我们可以通过相应的取值方法将数据取出。 Tips 官方文档中提到，即使没有主动采取数据保存，Activity的某些状态也会由预设 onSaveInstanceState() 实例还原。具体来说，预设实例会针对页面配置中的每一个View调用对应的 onSaveInstanceState()方法，UI中可见的变更都会自动保存，并在Activity重新构建时还原（如果组件没有ID，则系统无法储存其状态）。 如果想要禁用自动储存，只需要将android:saveEnabled设为”false”。 一些活动会重新构建的特殊情况当某些系统设置在程序运行阶段进行变更时（例如：屏幕方向、键盘可用性、语言）。针对这些情况应该考虑到数据存储和恢复。 结语好想出去玩！","link":"/2020/02/21/Android%E4%B8%AD%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"此处的第一篇博客","text":"写在这里的第一篇博客 这个博客的起因机缘巧合，这是一个特殊的新年，冠状病毒席卷华夏大地（都要从一个蝙蝠说起），我也被困在家里，思来想去不能干长肉啊！我要干点事情！又发现自己原来的博客各种意义上已经没法看了，所以决定从零开始建立一个新的博客——也就是这个。 说到底都怪那个没事吃蝙蝠的人。 先在这里立几个FLAG： + 好好学习安卓开发，写出来一个拿的出手的APP + 准备考研，但是还没想好考哪里 + 今年不当鸽子，把自己当年的旧账都收拾干净新年新气象，新博客也要确定一个全新的风貌！ BY Compass","link":"/2020/02/10/hello-world/"},{"title":"重走安卓路","text":"曾经半途而废放下的安卓开发，最终还是重新捡了起来。 起因最近没事就在逛酷安，酷安上活跃着很多独立开发者，和大厂的流氓行为不同，独立开发者往往在开发中遵循谷歌的开发标准，令安卓应用展现出应有的魅力，通过许多独立开发者开发的第三方应用，我逐渐淘汰掉许多大厂的第一方应用（这里要特别提一下share微博，提供了一个近乎完美的移动端微博使用体验！），也有许多效率应用慢慢改善着我的生活习惯。从一个应用中，能够看到作者本人的影子，可以说独立应用甚至可以说是作者美学的完美体现。 我怎么开始再次下载回郭霖大神写的《第一行代码》，现在快递停了，等风平浪静一定补票！ Android Studio则是一直躺在我的电脑里不用再布置环境了。 关于开发语言我也纠结过是不是直接去接触Flutter，但是考虑到Flutter目前终归还称不上一门成熟的语言，我决定还是从Java学起，慢慢接触Kotlin这门谷歌推崇的开发语言，毕竟这条路被许多前辈已经趟过，也算是一种比较稳妥的方案吧。 结束语我现在已结点开了PDF，结束完这篇文章，我就会从下一篇文章开始记录我的安卓学习之路！","link":"/2020/02/12/%E9%87%8D%E8%B5%B0%E5%AE%89%E5%8D%93%E8%B7%AF.html/"},{"title":"安卓之路·1","text":"开始了~ Android系统架构Android可分为四层架构，五块区域。 LINUX内核层——提供硬件的底层驱动 系统运行层——提供系统的主要特性支持，Android运行时库也在这一层，提供了一些核心库，允许开发者使用Java语言编写Android应用 应用框架层——提供构建应用程序时可能用到的API 应用层 Activity一般情况下，活动继承自AppCompatActivity，onCreate()方法继承自父类，我们实现功能则多是通过对这个方法的重写来实现。 所有活动需要在AndroidManifest.xml中注册才能生效，活动声明放在&lt;application&gt;标签内，通过&lt;activity&gt;标签对活动进行注册。 如何配置主活动？ 在&lt;activity&gt;标签内加入&lt;intent-filter&gt;标签，并在这个标签内添加 &lt;action android:name=”android.intent.action.MAIN”/&gt; &lt;category android:name=”android.intent.category.LAUNCHER”/&gt; 销毁一个活动：Activity类提供了一个finish()方法，通过调用这个方法可以销毁当前活动 活动状态活动在生命周期中最多可能有四种状态： 运行状态 暂停状态 停止状态 销毁状态 Activity类中定义了7个回调方法： onCreate()。会在活动第一次被创建时调用，完成活动的初始化。 onStart()。在活动由不可见变为可见时调用。 onResum()。在活动准备好和用户交互时调用。 onPause()。当系统准备去启动或回复另一个活动时调用。 onStop()。当活动完全不可见时调用。 onDestroy()。在活动被销毁之前调用，之后的活动状态为销毁状态。 onRestat()。这个方法在活动由停止状态变为运行状态之前调用。 如何保证在活动被回收后，恢复活动的状态？ Activity提供了onSaveInstanceState()回调方法临时保存数据。 onSaveInstanceState()方法可以携带一个Bundle类型的参数，Bundle提供了一系列方法用于保存数据，名保存方法需要传入两个参数，第一个参数是键（用于取回值），第二个是需要保存的参数。 保存代码实例如下： @Override protected void onSaveInstanceState(Bundle outState){ super.onSaveInstanceState(outState); String tempData = &quot;Someting you just typed&quot;; outState.putString(&quot;data_key&quot;,tempData); } 恢复数据的代码应当写在onCreate()方法，如下所示 @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (saveInstanceState != null){ String tempData = savedInstanceState.getString(&quot;data_key&quot;); } } 这里传递数据的方式和Intent传递信息的方式是十分类似的。 活动的启动方式有四种启动方式 standard singleTop singleTask singleInstance 具体的区别这里不再阐述 小结发现拾起来要比第一次学顺畅不少，当时许多无法理解的点也都很容易的理解了，不过效率还要提升！马上开始上网课了，考虑用水课的时间拿来学Android（？好孩子不要学）、 希望这是一个好的开始，能够坚持下去！","link":"/2020/02/12/%E5%AE%89%E5%8D%93%E4%B9%8B%E8%B7%AF1.html/"},{"title":"安卓之路2","text":"安卓学习的第二篇内容 IntentIntent是在活动之间跳转不可少的方法 显式IntentIntent是Android中组件之间进行交互的重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。 Intent可大致分为两种显式Intent和隐式Intent，先来学习显式Intent的使用。 Intent有多个构造函数的重载，其中一个是Intent(Context packageContext, Class&lt;?&gt; cls)，构造函数接受两个参数，Context参数要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动。 在使用Intent是，Activity类提供了一个startActivity()方法，这个方法是专门用于启动活动的，该方法接收Intent，将构建好的Intent传入方法即可启动目标活动。 隐式Intent隐式Intent不指明我们想启动哪一个活动，而指定一些列action和category等信息，然后交由系统区分写这个Intent，找出合适的活动去启动。（合适的活动是什么？A：可以响应Intent的活动） 通过配置&lt;activity&gt;标签下的&lt;intent-filter&gt;，可以指定当前活动可以响应的action和category： &lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.compass.demo.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这种配置使SecondActivity活动可以响应action为com.compass.demo.ACTION_START且category为android.intent.category.DEFAULT的活动。 通过隐式Intent还可以实现调用其他程序的活动的目的，利用这种功能可以实现浏览网页等功能。 向下一个活动传递数据Intent提供了一系列putExtra()方法的重载，可以把我们向传递的数据暂存在Intent中，启动了另一个活动之后，只需要把这些数据再从Intent中取出来就可以了！下面是一个传递字符串的例子： //传递部分，位于发起活动 button1.setOnClick(new View.OnclickListener(){ @Override public void onClick(View v){ String data = &quot;Compass forever！&quot;; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); intent.putExtra(&quot;extra_data&quot;, data); startActivity(intent); } }); //接收部分，位于目的活动 public class SecondActivity extends AppCompatActivity{ @Override protected void onCreat(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.second_layout); Intent intent = getIntent(); String data = intent.getStringExtra(&quot;extra_data&quot;); Log.d(&quot;SecondActivity&quot;,data); } } getStringExtra()用于接收字符串 getIntExtra()用于接收整型数据 getBooleanExtra()接收布尔型数据 返回数据给上一个活动startActivityForResult()方法可以满足我们在下个活动销毁时返回结果给上一个活动的需求。这个方法接收两个参数，第一个参数是intent，第二个参数是请求码（用于在回调中判断数据的来源）。 使用这种方法启动活动，需要在被启动的活动内构建一个Intent，在这里这个Intent仅仅用于传递数据而已。我们通过putExtra()将要传递的数据存放在Intent中，然后调用setResult()方法，setResult方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值，第二个参数则把带有数据的Intent传递回去。 在原活动中重写onActivityResult()方法来获取返回的数据，如下图所示： onActivityResult()方法带有三个参数，第一个参数requestCode是启动时传入的请求码，第二个参数resultCode是我们返回数据时传入的处理结果，第三个参数则是携带着返回数据的Intent。 结语这次主要学习了Intent相关的知识，考虑到明天（2020.2.17）就要开启网课的第一天了，所以这次的内容可能会稍微少一点点。 按照学习进度，接下来应该是要学习活动的生命周期相关的知识了，这是很重要的一部分，所以我可能会用很大的篇幅来记录学习过程。加油！","link":"/2020/02/15/%E5%AE%89%E5%8D%93%E4%B9%8B%E8%B7%AF%C2%B72/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"胡言乱语","slug":"胡言乱语","link":"/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"}],"categories":[{"name":"安卓学习","slug":"安卓学习","link":"/categories/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/"},{"name":"杂谈","slug":"安卓学习/杂谈","link":"/categories/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"}]}